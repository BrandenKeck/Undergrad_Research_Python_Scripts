#! /usr/bin/env python
#This code will plot user-selected isotherm data, and can also plot literature data.
#This code will create a constant temperature isotherm plot. It should be executed in the directory containing all of the loading directories for a specified condition, i.e. temperature.
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import gridspec
from matplotlib import rc
import math
import readline
import sys
import time
import subprocess

def main():
	#Set some initial params
	readline.parse_and_bind("tab: complete")
	readline.set_completer_delims(readline.get_completer_delims().replace('-',''))
	
	#Isotherms found with function (see below)
	availableIsotherms = findIsotherms()
	
	print('Available isotherms for plotting:\n')
	for j, line in enumerate(availableIsotherms):
		print('{0}: {1}'.format(j,line))
	print('\nEnter the numbers corresponding to the calculations you would like to plot, separated by spaces.\n')
	calcNumbers = raw_input('For example: 0 1\n')
	calcNumList = np.unique(np.array([int(s) for s in calcNumbers.split() if s.isdigit()]))
	dataSetLabels = np.array([])
	kolor = np.array(['g','r','k','m','c','b','y'])
	#compute all relevent data
	data = []
	
	#Empty arrays for table variables
	rowlabel = []
	collabel = []
	celldata = []
	
	for count, p in enumerate(calcNumList):
		#get pressures from the current directory
		Dirs = subprocess.Popen('ls -d */', stdout=subprocess.PIPE, cwd=availableIsotherms[p], shell=True)
		Pressures = Dirs.communicate()[0].replace("mbar/\n"," ").split()
		pres = np.sort(np.array([float(i) for i in Pressures]))
		label = subprocess.Popen('printf "%s" "${PWD##*/}"', stdout=subprocess.PIPE, cwd=availableIsotherms[p], shell=True)
		label = label.communicate()[0]
		
		#Empty arrays for isotherm data
		pressure = []
		loading = []
		err = []
		pErr = []
		time = []
		pEq = []
		
		#Statistic variables
		tTime = 0
		tErr = 0
		aPerErr = 0
		aPerEq = 0
		
		for sure in pres:
			loc = availableIsotherms[p]+'/'+'{0}mbar/Output/System_0/'.format(str(sure))
			getData = subprocess.Popen('grep -F "Average loading excess [cm^3 (STP)/g" output_*', stdout=subprocess.PIPE, cwd=loc, shell=True)
			l = float(getData.communicate()[0].split()[6])
			getData = subprocess.Popen('grep -F "Average loading excess [cm^3 (STP)/g" output_*', stdout=subprocess.PIPE, cwd=loc, shell=True)
			e = float(getData.communicate()[0].split()[8])
			getData = subprocess.Popen('grep -F "total time" output_*', stdout=subprocess.PIPE, cwd=loc, shell=True)
			t = float(getData.communicate()[0].split()[2])
			eq = percentEquilibrated(loc)
			
			pressure.append(sure)
			loading.append(l)
			err.append(e)
			try:
				pErr.append(e/l * 100)
			except:
				pErr.append(0)
			time.append(t)
			pEq.append(eq)
			
			tTime += t
			tErr += e
			 
		aPerErr = sum(pErr)/len(pErr)
		aPerEq = sum(pEq)/len(pEq)
		data.append([availableIsotherms[p], pressure, loading, err, pErr, time, pEq, tTime, tErr, aPerErr, aPerEq])
		rowlabel.append(label)
		collabel = ["Total Time", "Total Error", "Average Percent Error", "Average Percent Equilibrated"]
		celldata.append([tTime, tErr, aPerErr, aPerEq])
	
	fig = plt.figure()
	gs = gridspec.GridSpec(1, 3)
	
	ax1 = fig.add_subplot(gs[0,0])
	ax2 = fig.add_subplot(gs[0,1])
	ax3 = fig.add_subplot(gs[0,2])
	
	ax1.set_xlabel("Pressure (mbar)")
	ax2.set_xlabel("Pressure (mbar)")
	ax3.set_xlabel("Pressure (mbar)")
	
	ax1.set_ylabel("Percent Deviation")
	ax2.set_ylabel("Total CPU Time (s)")
	ax3.set_ylabel("Percent Equilibrated")
	
	kolor = np.array(['g','r','k','m','c','b','y'])
	for k in range(0, len(data)):
		iLabel = raw_input("\nEnter label for isotherm " + str(k) + ":   ")
		ax1.plot(data[k][1], data[k][4], label=iLabel, linestyle='-', linewidth=3, color=kolor[k])
		ax2.plot(data[k][1], data[k][5], label=iLabel, linestyle='-', linewidth=3, color=kolor[k])
		ax3.plot(data[k][1], data[k][6], label=iLabel, linestyle='-', linewidth=3, color=kolor[k])

	plt.legend(loc=7,prop={'size':16})
	plt.show()
		
#Function using original IPG code to gather available isotherms:
#identify all the isotherms that could be plotted, but first open a dump file for error output
def findIsotherms():
	#determine who the user is
	loadingBar("Identifying User", 1, 10)
	user = subprocess.Popen(r'whoami', stdout=subprocess.PIPE)
	name = str(user.communicate()[0].split()).replace("['","").replace("']","")
	loadingBar("Creating Temporary Files", 2, 10)
	if name == 'jpr54':
		f = open('/ihome/kjohnson/jpr54/trash.txt', "w")
	elif name == 'bmk62':
		f = open('/ihome/kjohnson/bmk62/trash.txt', "w")
	loadingBar("Looking for isotherms in Jon's directories...", 3, 10)
	user1Path = '/ihome/kjohnson/jpr54/raspa/isotherms'
	user1gen = subprocess.Popen('find -name "Isotherm" -printf "%h\n"', stdout=subprocess.PIPE, stderr=f, cwd=user1Path, shell=True)
	loadingBar("Parsing data from Jon's directories...", 4, 10)
	user1Locs = user1gen.communicate()[0].split()
	user1Locs = [k.split('.',1)[1] for k in user1Locs]
	loadingBar("Parsing data from Jon's directories...", 5, 10)
	user1LocsF = [user1Path+'{0}'.format(b) for b in user1Locs]
	loadingBar("Looking for isotherms in Branden's directories...", 6, 10)
	user2Path = '/ihome/kjohnson/bmk62'
	user2gen = subprocess.Popen('find -name "Isotherm" -printf "%h\n"', stdout=subprocess.PIPE, stderr=f, cwd=user2Path, shell=True)
	loadingBar("Parsing data from Branden's directories...", 7, 10)
	user2Locs = user2gen.communicate()[0].split()
	user2Locs = [M.split('.',1)[1] for M in user2Locs]
	loadingBar("Parsing data from Branden's directories...", 8, 10)
	user2LocsF = [user2Path+'{0}'.format(N) for N in user2Locs]
	f.close()
	loadingBar("Removing Temporary Files", 9, 10)
	if name == 'jpr54':
		subprocess.Popen('rm /ihome/kjohnson/jpr54/trash.txt', shell=True)
	elif name == 'bmk62':
		subprocess.Popen('rm /ihome/kjohnson/bmk62/trash.txt', shell=True)
	loadingBar("Wrapping Up...", 10, 10)
	availableIsotherms = user1LocsF + user2LocsF
	return availableIsotherms;

def percentEquilibrated(location):
	#define arrays
	ness = []
	density = []
	prodDensity = []
	cycles = []
	prodCycles = []

	#get cycle interval and number of init cycles
	getInitCycles = subprocess.Popen(r'grep -F "Number of initializing cycles:" output_*', stdout=subprocess.PIPE, cwd=location, shell=True)
	numInit = float(getInitCycles.communicate()[0].split()[4])

	getInterval = subprocess.Popen(r'grep -F "Print every" output_*', stdout=subprocess.PIPE, cwd=location, shell=True)
	interval = float(getInterval.communicate()[0].split()[2])

	#get density string
	getData = subprocess.Popen(r'grep -F "density" output_*', stdout=subprocess.PIPE, cwd=location, shell=True)
	ness = getData.communicate()[0]
	ness = ness.split("density: ")

	#parse string
	for index in range(2, len(ness)):
		onett = []
		onett = ness[index].split(" ")
		j = 0
		k = 0
		while j == 0:
			if(onett[k] == ''):
				k = k+1
			else:
				density.append(float(onett[k]))
				j = 1
	density.insert(0, 0.0000)

	#create data array
	for index in range(0, len(density)):
		cycNum = interval*index
		cycles.append(cycNum)
		if(cycNum > numInit):
			prodDensity.append(density[index])
			prodCycles.append(cycNum)
	
	#Calculate best fit
	xbar = sum(prodCycles)/len(prodCycles)
	ybar = sum(prodDensity)/len(prodDensity)
	n = len(prodCycles) # or len(Y)
	numer = sum([xi*yi for xi,yi in zip(prodCycles, prodDensity)]) - n * xbar * ybar
	denum = sum([xi**2 for xi in prodCycles]) - n * xbar**2
	slope = numer / denum
	pEq = 100/(10000*math.fabs(slope)+1)
	return pEq;
	
#save plot function using original IPG code
def savePlot(title):
	pControl = 0
	while pControl != 1:
		savePlot = raw_input('\nsave the plot? y/n\n')
		if (savePlot == 'y'):
			plt.savefig(title)
			pControl = 1
		elif (savePlot == 'n'):
			pControl = 1
		else:
			print('try again\n')
	plt.show()

# function that creates latex-table, pulled from a SO example by Schorsch
def latex_table(celldata,rowlabel,collabel):
    table = r'\begin{table} \begin{tabular}{|1|'
    for c in range(0,len(collabel)):
        # add additional columns
        table += r'1|'
    table += r'} \hline'

    # provide the column headers
    for c in range(0,len(collabel)-1):
        table += collabel[c]
        table += r'&'
    table += collabel[-1]
    table += r'\\ \hline'

    # populate the table:
    # this assumes the format to be celldata[index of rows][index of columns]
    for r in range(0,len(rowlabel)):
        table += rowlabel[r]
        table += r'&'
        for c in range(0,len(collabel)-2):
            if not isinstance(celldata[r][c], basestring):
                table += str(celldata[r][c])
            else:
                table += celldata[r][c]
            table += r'&'

        if not isinstance(celldata[r][-1], basestring):
            table += str(celldata[r][-1])
        else:
            table += celldata[r][-1]
        table += r'\\ \hline'

    table += r'\end{tabular} \end{table}'
    return table;

	
def loadingBar(ldwht, length, outof):
	print("\n\n")
	sys.stdout.write("\033[F")
	sys.stdout.write("\033[F")
	sys.stdout.write("\033[F")
	print("Gathering Isotherm Data:   ")
	print("[[" + "|" * length*3 + " " * (outof-length)*3 + "]]")
	print(ldwht + " "*50)
	sys.stdout.write("\033[F")
	sys.stdout.write("\033[F")
	sys.stdout.write("\033[F")
	time.sleep(1)
	return;
	
if __name__ == "__main__":
	main()	